### 중복이 허용되어 주어진 mass spectrum 내에서
### 57~200 사이의 Convolution spectrum의 상위 m개
### leaderboard의 상위 n개 내에서 Cyclopeptide sequencing
### 계산이 되어 결과가 나오긴 하지만, 중복 계산도 많아보이고 효율적이지 못해, 수정이 필요

import numpy as np

################################################################
### Convolution Top m (ba4h.py)

def convolution(spectrum,m):
    
        spectrum.sort()
        diff = np.zeros((len(spectrum)-1, len(spectrum)-1))
        for i in range(len(spectrum)):
            for j in range(i + 1, len(spectrum)):
                diff[i-j, j - 1] = spectrum[j] - spectrum[i]
        
        convoluted = []
        elements = diff[diff != 0].flatten()
        uniq_elems, counts = np.unique(elements, return_counts=True)
        sorted_elems = np.argsort(-counts)
        for index in sorted_elems:
            convoluted.extend([uniq_elems[index]] * counts[index])
        
        topm = {}
        convoluted = [x for x in convoluted if 57 <= x <= 200]
        for item in convoluted:
            if item not in topm:
                topm[item] = 1
            else:
                topm[item] += 1

        return topm

#####################################################
### ba4e : peptide -> cyclospectrum

def rolling(peptide):
    cyclepeps = [0, sum(peptide)]
    # print(cyclepeps)
    largerpeps = peptide + peptide
    for after in range(1, len(peptide)):
        for before in range(len(peptide)):
            subpeptide = largerpeps[before:before + after]
            cyclepeps.append(sum(subpeptide))
    cyclepeps.sort()
    # print(cyclepeps)
    return cyclepeps

#####################################################
### ba4f : calculate score

def scoring(peptide, spectrum):
    pep_spec = rolling(peptide)
    result = 0
    unique_masses = set(pep_spec + spectrum)
    for mass in unique_masses:
        result += min(pep_spec.count(mass), spectrum.count(mass))
    return result

#####################################################

def leaderboard_pep(spectrum, top_nth, integer_mass_table):
    
    leaderboard = [[]]
    leader_peptide = []
    
    while leaderboard:
        updates = []
        for pep in leaderboard:
            for mass in integer_mass_table.keys():
                updates.append(pep + [mass])
        leaderboard = updates
        print(leader_peptide, leaderboard)
        
        for peptide in leaderboard[:]:
            if sum(peptide) == spectrum[-1]:
                if scoring(peptide, spectrum) > scoring(leader_peptide, spectrum):
                    leader_peptide = peptide
            elif sum(peptide) > spectrum[-1]:
                leaderboard = [pep for pep in leaderboard if pep != peptide]

        if len(leaderboard) > top_nth:
            score = {}
            for ith, peps in enumerate(leaderboard):
                score[ith] = scoring(peps, spectrum)
            
            threshold = sorted(score.values(), reverse=True)[top_nth-1]
            leaderboard = [pep for pep in leaderboard if scoring(pep, spectrum) >= threshold]
    
    return leader_peptide

#####################################################

with open('bioinfo2/sample.txt', 'r') as f:
    m = int(f.readline().strip())
    n = int(f.readline().strip())
    spectrum = list(map(int, f.readline().split()))

print(m, n, spectrum)

topm = convolution(spectrum, m)
print(leaderboard_pep(spectrum, n, topm))
